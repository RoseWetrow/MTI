# MTI
### MTI (Moscow Transport Information) — telegram бот, предоставляющий информацию о любом, интересующем вас маршруте или остановке, в удобном формате.

<img src="https://github.com/user-attachments/assets/ec3c5ff5-fb80-4b3b-977b-a78267933319" width="500" alt="logo">

> [!NOTE]
> В условиях высокой динамики городской среды пользователи стремятся получать оперативную и достоверную информацию о маршрутах общественного транспорта. Особенно остро эта потребность выражена в таких крупных мегаполисах, как Москва, где транспортная система отличается высокой плотностью маршрутов и большим количеством пересадочных узлов.\
> Традиционные способы получения такой информации — стационарные расписания на остановочных пунктах, мобильные приложения или веб-сервисы зачастую оказываются избыточными или неудобными в использовании.\
> Например, некоторые приложения требуют установки, регистрации, длительной загрузки данных или содержат ненужный функционал.\
> В этом контексте возникает потребность в интуитивном и легком интерфейсе взаимодействия, способном быстро предоставлять необходимые данные по запросу пользователя.
>
> За последние годы в Москве была проведена активная работа по цифровизации городской инфраструктуры, в том числе в области транспорта.\
> Одним из центральных источников таких данных стал [«Портал открытых данных Правительства Москвы»](https://data.mos.ru/) (data.mos.ru), запущенный в 2013 году.\
> Это единая городская платформа, предоставляющая публичный доступ к структурированным, и регулярно обновляемым данным, необходимым для разработки информационных и аналитических решений. На момент июня 2025 года на портале опубликовано свыше 1200 наборов данных, охватывающих различные сферы городской жизни: образование, здравоохранение, культура, недвижимость, экология, экономика, благоустройство и, транспорт.\
> Среди поставщиков данных фигурируют различные департаменты, управления, комитеты и инспекции. Каждый набор данных сопровождается описанием, ответственным лицом и периодичностью обновления, что гарантирует высокую степень стабильности.\
> В области транспорта ключевым поставщиком информации выступает Департамент транспорта и развития дорожно-транспортной инфраструктуры города Москвы.

> [!TIP]
> Все материалы портала доступны по лицензии [Commons Attribution 4.0](https://data.mos.ru/terms), что позволяет использовать данные в любых целях, включая коммерческие (при условии обязательного указания ссылки на первоисточник). 

## Особенности предоставления транспортных данных
Для реализации телеграм-бота, предоставляющего информацию о наземном общественном транспорте Москвы, необходимы наборы данных (датасеты), предоставленные Департаментом транспорта и развития дорожно-транспортной инфраструктуры города Москвы, в частности, четыре взаимосвязанных датасета, на которых далее будет завязана вся логика обработки запросов:
-	 «Маршруты»;
-	«Рейсы маршрутов»;
-	«Расписание рейсов»;
-	«Остановки».

> [!TIP]
> Эти датасеты построены в соответствии со спецификацией GTFS (General Transit Feed Specification) — открытым отраслевым стандартом, разработанным компанией Google.\
> GTFS представляет собой коллекцию файлов (как минимум из 6 и до 13 наборов), содержащих информацию о маршрутах, остановках, расписании и структуре перевозок. Он широко используется в транспортных приложениях и позволяет обеспечивать совместимость данных с навигационными сервисами и маршрутными планировщиками.\
> Для проекта выбраны только четыре взаимосвязанных датасета из 6-ти обязательных структурных составляющих GTFS. Остальные: «Календарь маршрутов» и «Транспортные предприятия» не являются необходимыми.\
> Каждый из наборов, представляет собой структурированную таблицу с полями, содержащими уникальные идентификаторы, текстовые описания маршрутов и остановок, а также вспомогательную информацию: тип транспорта, направления движения, последовательность следования, координаты и другие атрибуты.

На рисунке 1 и 2 представлены примеры структур данных набора «Маршруты» и «Остановки».

<img src="https://github.com/user-attachments/assets/e81b4d12-900f-46cf-8bd0-fcd1c5ab429e" width="400">

Рисунок 1 – Пример данных датасета «Маршруты»

<img src="https://github.com/user-attachments/assets/9af96056-9edd-4fc9-9e8c-57dfafcd4871" width="400">

Рисунок 2 – Пример данных датасета «Остановки»

Как видно из рисунков выше, наборы «Маршруты» и «Остановки» содержат информацию о конкретном маршруте или остановке соответственно. В свою очередь, наборы «Рейсы маршрутов» и «Расписание рейсов» являются связующими.\
«Рейсы маршрутов» связывают через уникальные идентификаторы каждый маршрут с рейсом, а «Расписание рейсов» каждый рейс с остановками.\
У каждого маршрута из набора «Маршруты» может быть несколько направлений следования (образно говоря: прямо и обратно) — соответственно, несколько кодов рейсов в наборе «Рейсы маршрутов». Эти коды рейсов связывают каждый маршрут с конкретной остановкой и ее номером по пути следования в наборе «Расписание рейсов», тем самым формируя список остановок по пути следования в двух направлениях (или в одном, если автобус в определенный момент следования разворачивается, а не прибывает на конечную).\
Прослеживаемая зависимость представлена на рисунке 3.

<img src="https://github.com/user-attachments/assets/c5c68942-1d1d-4ea9-88c8-8afd936ef69c" width="700">

Рисунок 3 – Диаграмма связей датасетов

На портале data.mos.ru транспортные наборы, публикуются в формате, удобном для интеграции: 
-	таблицы с возможностью экспорта через веб-интерфейс в формате CSV, XLSX или JSON;
-	программный доступ через API, позволяющий выполнять запросы к данным и получать результаты в формате JSON.

## Проектирование БД
На основании анализа структуры предоставляемых транспортных данных, а также изучения спецификации GTFS, была спроектирована собственная БД, предназначенная для хранения актуальной информации о маршрутах, остановках и расписании общественного транспорта Москвы.\
Разработка структуры БД производилась с учетом необходимости последующей автоматической синхронизации данных с порталом открытых данных и обеспечения быстрой обработки пользовательских запросов со стороны telegram-бота.\
В результате проектирования была сформирована реляционная БД, состоящая из пяти логически взаимосвязанных таблиц (рис. 4).

<img src="https://github.com/user-attachments/assets/43efc522-bee7-46bd-a312-d13c8d2570bb" width="700">
 
Рисунок 4 – Диаграмма БД

1.	`dataset_versions` — служебная таблица, хранящая информацию о версии загруженных наборов данных. Используется исключительно модулем автоматического обновления:

    | Поле            | Тип      | Описание                          |
    |-----------------|----------|-----------------------------------|
    | id              | INT      | Первичный ключ                    |
    | dataset_name    | VARCHAR  | Название набора данных            |
    | release_number  | INT      | Номер актуальной версии           |

2.	`routes` — таблица маршрутов, содержащая базовую информацию о транспортных маршрутах:
    
    | Поле               | Тип      | Описание                          |
    |--------------------|----------|-----------------------------------|
    | route_id           | VARCHAR  | Уникальный идентификатор маршрута |
    | route_short_name   | VARCHAR  | Номер маршрута (например "903")   |
    | route_long_name    | VARCHAR  | Полное описание маршрута (например «Останкино - Восточное Измайлово»)          |

3.	`route_flights` — таблица рейсов маршрутов, содержащая информацию о конкретных направлениях движения:

    | Поле          | Тип      | Описание                          |
    |---------------|----------|-----------------------------------|
    | trip_id       | VARCHAR  | Уникальный идентификатор рейса    |
    | route_id      | VARCHAR  | Ссылка на таблицу `routes`        |
    | direction_id  | INT      | Направление движения (0 — прямое, 1 — обратное)    |
  	
4.	`route_schedule` — таблица, связывающая рейсы с остановка по пути следования:

    | Поле           | Тип      | Описание                          | 
    |----------------|----------|-----------------------------------|
    | trip_id        | VARCHAR  | Ссылка на таблицу `route_flights`               |
    | stop_sequence  | FLOAT    | Порядковый номер остановки на маршруте        |
    | stop_id        | FLOAT    | Ссылка на таблицу `stops`            |

Составной первичный ключ (trip_id, stop_sequence) данной таблицы позволяет однозначно идентифицировать порядок следования остановок для каждого конкретного рейса. Такое проектное решение обусловлено тем, что в процессе обновления данных порядок остановок может меняться (например, при добавлении новой остановки), при этом trip_id остается неизменным. Использование составного ключа гарантирует целостность данных и актуальность маршрутов при изменениях.

5.	`stops` — таблица остановок:

    | Поле       | Тип      | Описание                          |
    |------------|----------|-----------------------------------|
    | stop_id    | INT      | Уникальный идентификатор остановки|
    | stop_name  | VARCHAR  | Название остановки           |
    | lat        | NUMERIC  | Географическая широта            |
    | lng        | NUMERIC  | Географическая долгота           |

Стоит заметить, что изначально структура данных предполагает установление внешних ключей между таблицами, что соответствовало бы классическому подходу к проектированию реляционной модели и следованию нормальных форм. Однако от жесткого связывания таблиц внешними ключами было решено отказаться по следующим причинам:
-	наборы, размещенные на data.mos.ru, периодически обновляются, при этом изменения в одном наборе (например, добавление новой остановки в «stops») влекут за собой изменения в связанных наборах, что подразумевает их обновление. Поэтому в таких случаях происходит актуализация связанных таблиц, а проверка ссылочной целостности становится избыточным и потенциально опасным для стабильности системы;
-	в случае жестких внешних связей в БД, удаление или обновление одной записи при частичном обновлении набора может привести к ошибкам целостности или автоматическому каскадному удалению связанных записей, что повлечет ошибку целостности данных и ее достоверности, как следствие;
Таким образом, архитектура БД реализована с упором на гибкость и надежность при периодической полной актуализации.

##	Модуль обновления данных
В рамках реализации распределенной информационной системы был разработан отдельный модуль, отвечающий за регулярную синхронизацию локальной БД с официальными источниками открытых данных города Москвы. Транспортные наборы данных, размещенные на портале data.mos.ru, регулярно обновляются: изменяются маршруты, добавляются или удаляются остановки, корректируется расписание. Использование устаревших данных может привести к предоставлению пользователю недостоверной информации, что недопустимо для системы, ориентированной на надежность и актуальность.\
Для автоматизации этого процесса была реализована фоновая система обновления данных, выполняющая следующие функции:
-	определение актуальности локальных данных;
-	при необходимости — скачивание новых версий датасетов с помощью API;
-	предварительная обработка и очистка данных;
-	замена старых записей в основной базе данных;
-	обновление информации о текущих версиях данных;
-	сохранение даты последнего обновления.

Архитектура модуля.
Модуль построен с соблюдением принципов модульности и разделения ответственности. Логика работы была распределена по нескольким отдельным файлам:
1.	`updates_main.py` — основной управляющий модуль. Содержит словарь DATASETS с ID нужных датасетов, метод checkingForUpdates() для проверки актуальности и запуска обновлений, а также функции fetch_insert_datasets() и fetch_page() для загрузки и записи данных.
2.	`api_work.py` — вспомогательные функции для взаимодействия с API портала открытых данных. Содержит методы get_remote_versions() (получение актуальных версий), get_dataset_count() и get_dataset_data() (постраничная загрузка данных).
3.	`db_work.py` — функции работы с PostgreSQL: db_insert() (вставка данных), temp_table_actions() (обработка временных таблиц), get_local_versions() и update_local_versions() (чтение и обновление версий).
4.	`dates.py` — вспомогательные методы для хранения и получения даты последнего обновления: save_current_date_to_file() и read_last_date_from_file().
5.	`relevance.txt` — файл хранения даты последнего успешного обновления в формате ДД.ММ.ГГГГ (используется в dates.py).
Структура обеспечивает изоляцию компонентов, облегчает сопровождение и упрощает возможную доработку в будущем.

##  Модуль обработки данных
Для реализации Telegram-бота был выбран фреймворк aiogram, поддерживающий асинхронную архитектуру. В качестве средства взаимодействия с БД в рамках обработки пользовательских запросов выбрана библиотека asyncpg, что позволило достичь высокой производительности и эффективной интеграции с остальными компонентами системы.\
### Основные сценарии пользовательского взаимодействия.
Система ориентирована на реализацию двух ключевых пользовательских сценариев:
1.	Запрос маршрута по его номеру.
При вводе сообщения в формате: /<номер маршрута> (например, /29) бот выполняет поиск соответствующего маршрута в базе данных. Пользователю предлагается список маршрутов с совпадающим номером (route_short_name), каждый из которых отображается с уточненным полным названием (route_long_name). После выбора маршрута выводится список остановок в обоих направлениях движения.
2.	Запрос информации об остановке.
При вводе сообщения в формате: //<название остановки> (например, //Политехнический университет), бот выполняет поиск совпадений в таблице остановок. Пользователю предлагаются варианты, наиболее соответствующие запросу. После выбора конкретной остановки отображается список маршрутов, проходящих через нее, а также предоставляется адрес и ссылка на карту.\
Помимо основных сценариев, реализованы вспомогательные команды и элементы управления потипу команды /start и кнопок «О боте», «Назад», «Очистить».
### Логика SQL-запросов.
При обработке пользовательских запросов система должна учитывать множество особенностей, обусловленных структурой и объемом данных. В данном проекте прослеживается следующая логика взаимодействия с БД:
-	введенный маршрут или остановка может отсутствовать в базе — в таком случае пользователь должен информироваться об отсутствии информации;
-	по одному номеру маршрута (route_short_name) может быть найдено несколько различных маршрутов (route_id), отличающихся типом транспорта, направлением или маршрутом (например, электробус и трамвай с одним и тем же номером);
-	маршрут (route_id) может иметь несколько рейсов (trip_id), соответствующих различным направлениям или временным интервалам;
-	у каждого рейса может быть одно или два направления движения (значения direction_id — 0 и 1);
-	в некоторых случаях один и тот же рейс представлен в базе в нескольких вариантах (например, при обновлении данных на портале без удаления старых записей);
-	по одному названию остановки может быть найдено от одной до нескольких десяток остановок (например, если пользователь ввел общее или частичное название), различающихся по расположению (на прямом и обратном направлении) или stop_id (схожее название/вхождение, но в разных местах города).

Учитывая все эти особенности, запросы к базе данных строятся поэтапно: начиная с фильтрации по ключевому полю (route_short_name или stop_name), далее выполняется дополнительная выборка, группировка и сортировка для исключения дублей и формирования корректного списка для отображения пользователю. В некоторых случаях используется предварительная проверка на количество совпадений, чтобы избежать избыточного вывода информации, ошибок фильтрации и излишней нагрузки на систему.
### Архитектура модуля.
Модуль Telegram-бота построен с соблюдением принципов модульности и разделения ответственности. Логика работы разделена между несколькими файлами, каждый из которых отвечает за строго определенную область функциональности:
1.	main_bot.py — главный исполняемый файл, в котором инициализируется Dispatcher и Bot, настраиваются команды (/start) и сообщения, обрабатываются inline-кнопки (маршруты, остановки, информация о боте) и реализован запуск polling-цикла и очистка pending updates при старте.
2.	query_routes_logic.py — модуль, отвечающий за обработку запросов, связанных с маршрутами, в котором происходит выполнение SQL-запросов для поиска маршрутов и рейсов, выборка остановок для каждого направления и формирование итогового сообщения пользователю.
3.	query_stops_logic.py — модуль, реализующий логику запросов по остановкам, в которм происходит поиск остановок по имени, выборка проходящих маршрутов, сбор итоговой информации о маршрутах и геолокации.
4.	geo.py — модуль геокодирования, где формируются ссылки на карту на основе координат остановки и возвращается полный адрес и URL на карту для отображения пользователю.
5.	state.py — вспомогательный модуль, содержащий словарь состояний пользователя, используемый для хранения промежуточных результатов на разных этапах запроса.
6.	keyboards.py — содержит определения inline-клавиатур: начальное меню, кнопки возврата и очистки и кнопки выбора маршрутов и остановок.

## Демонстрация процесса обновления данных
Вся логика актуализации информации реализована в виде отдельного модуля, работающего в фоновом режиме. Модуль регулярно проверяет версии официальных датасетов, размещенных на портале data.mos.ru, и при обнаружении новых версий инициирует обновление соответствующих таблиц в локальной базе данных.\
Обновление происходит в несколько этапов:
-	получение локальных и удаленных версий;
-	определение несоответствий;
-	параллельная загрузка данных по частям (batch-запросами);
-	создание временных таблиц в базе данных;
-	их замена основной таблицей с помощью транзакций;
-	фиксация новых версий в таблице «dataset_versions»;
-	обновление даты последней актуализации.

На рисунке 5 представлен консольный вывода при запуске модуля в момент, когда на data.mos.ru вышли новые версии всех 4 наборов.

<img src="https://github.com/user-attachments/assets/957ed477-8ce6-472c-98d6-77fcb098ba2d" width="600">
 
Рисунок 5 — Процесс актуализации данных

Как видно на рисунке выше: сперва происходит сравнение версий локальных и удаленных датасетов, далее определяется новая версия и количество строк в датасете, создается временная таблица и происходит последовательная загрузка информации с портала. В случае с набором routes хватило только одного запроса, так как в нем всего 878 записей. После этого старая таблица удаляется, а временная заменяется на основную.\
Далее, по той же схеме, происходит проверка актуальности следующего датасета «route_flights». На рисунке 6 представлена созданная временная таблица в обозревателе DBeaver.

<img src="https://github.com/user-attachments/assets/0dfa8915-0bfe-4b25-9c48-b2b4c13f08de" width="300">

Рисунок 6 — Созданная временная таблица в БД

Далее последовательно заполняются оставшиеся таблицы. На рисунке 7 показан процесс загрузки новой версии датасета «route_schedule» на 6097147 записей.

<img src="https://github.com/user-attachments/assets/be69ae5c-16eb-49d5-a9d0-d023a0aa40a7" width="450">
 
Рисунок 7 — Процесс заполнения таблицы «route_schedule»

На рисунке 7 отчетливо видно последовательное выполнение параллельных запросов пачками по 10 штук.\
Если какой-то запрос вернет пустое значение или вызовет ошибку, очередь подождет повторное выполнение и успешное получение данных с этого запроса, как это видно на рисунке 8.

<img src="https://github.com/user-attachments/assets/c5a94c06-9ece-4d9c-8cfc-e7c269a5b46d" width="450">

Рисунок 8 — Повторное выполнение запроса при возникновении ошибки

Как видно из рисунка выше, 9 из 10 запросов очередной пачки вернули 200 (успешный ответ от сервера), а 10-ый завершился ошибкой. После этого происходит повторная отправка запроса, и следующая пачка запросов отправится только после его успешного завершения.\
На рисунке 9 видно, как под конец рассчитывается значение параметра top.

<img src="https://github.com/user-attachments/assets/c4afbf6c-2550-4306-ab64-84634a86be47" width="450">

Рисунок 9 — Расчет параметра top под конец набора

После успешного обновления всех наборов, новые версии сохраняются в «dataset_versions» (рис. 10).

<img src="https://github.com/user-attachments/assets/02faa2fb-fa76-40a3-a784-2b79624d805b" width="300">
 
Рисунок 10 — Таблица «dataset_versions» с обновленными версиями 

Таким образом, можно убедиться, что система актуализации работает в автоматическом режиме и эффективно синхронизирует данные, что критически важно для поддержания достоверности предоставляемой пользователю информации.

## Демонстрация процесса работы бота
Для демонстрации работы telegram-бота ниже представлены примеры взаимодействия пользователя с ботом, соответствующие сценариям, описанным ранее.\
На рисунке 11 показан пример запроса по маршруту /375. Этот маршрут обслуживается маршрутным такси и имеет два направления движения. Система определяет наличие двух пар trip_id и direction_id. Бот выводит наименование маршрута и список всех остановок по пути следования в обоих направлениях.

<img src="https://github.com/user-attachments/assets/aab0e6ff-f153-4af9-a280-a9b69f3f6b26" width="400">
 
Рисунок 11 — Обработка маршрута с двумя направлениями

На рисунке 12 продемонстрирован маршрут /789, который представляет собой электробус. По данным в БД, маршрут имеет только один trip_id, что объясняется наличием только одной конечной остановки со стоянкой. 789 электробус доезжает до Ботанического сада от Лоси и разворачиваясь, едет обратно.

<img src="https://github.com/user-attachments/assets/95c51326-3334-43ae-8d9f-4b789459f507" width="400">
 
Рисунок 12 — Обработка маршрута с одним направлением

На рисунке 13 представлен ввод маршрута /11, по которому в БД содержится несколько записей, что объясняется наличием автобуса и трамвая под одним и тем же номером. В таком случае пользователю предлагается выбрать нужный вариант при помощи кнопок с наименованиями маршрутов.

<img src="https://github.com/user-attachments/assets/486621fb-0f8f-4e87-9a07-58bb9f32a76f" width="350">

Рисунок 13 — Обработка случая с несколькими найденными маршрутами

При выборе конкретного варианта пользователю так же выводится сообщение с информацией (рис. 14).

<img src="https://github.com/user-attachments/assets/a5688677-5ce5-40d7-aab2-defc2dd20ee4" width="400">
 
Рисунок 14 — Обработка случая с несколькими найденными маршрутами

Каждое сообщение, содержащее список остановок, дополнительно сопровождается кнопкой «Скрыть», которая позволяет пользователю удалить сообщение, чтобы не загромождать чат.\
Если какой-то маршрут вдруг не будет найден в БД, бот выведет соответствующее сообщение (рис. 15).

<img src="https://github.com/user-attachments/assets/39334e5e-5bfa-4bed-a3ac-2cd836f9d51b" width="350">

Рисунок 15 — Обработка случая с отсутствующим в БД маршрутом

Помимо маршрутов, важной функциональностью бота является возможность получения информации об остановках. В зависимости от количества совпадений, логика вывода информации так же варьируется.\
Один из типичных случаев — когда по введенному названию система находит две остановки с одинаковым именем, расположенные на противоположных сторонах дороги. Примером может служить ввод команды //Сержантская улица (можно ввести «//сержанская», так как запрос не зависит от регистра и ищет остановки по вхождению). В ответ бот выводит две интерактивные кнопки, соответствующие найденным остановкам.\
На рисунке 16 продемонстрирован пример такого взаимодействия.

<img src="https://github.com/user-attachments/assets/7ff643fa-4e97-41b7-9718-eeaf16f52f09" width="350">

Рисунок 16 — Обработка запроса с двумя найденными остановками

После нажатия на конкретную кнопку, пользователь получает полную информацию ою остановке (рис. 17).

<img src="https://github.com/user-attachments/assets/61e6a0d2-2f09-4cd3-9e57-302c0f76da92" width="400">
 
Рисунок 17 — Вывод информации об оставноке

Адрес, полученный с помощью Яндекс Геокодера, сопровождается активной ссылкой на карту, которая автоматически отображает превью с точным расположением остановки. Это делает взаимодействие максимально наглядным.\
Когда количество совпадений превышает две, но не более четырех, бот действует аналогичным образом: создает интерактивные кнопки, при нажатии на которые выводится полная информация об интересующей остановке. Примером может служить запрос //московский политех, в результате которого находится четыре остановки — трамвайные и автобусные платформы, расположенные вблизи университета.\
На рисунке 18 продемонстрировано, как бот обрабатывает подобный запрос.

<img src="https://github.com/user-attachments/assets/655e90a6-1637-4c8b-98a5-2d1fd216a2c6" width="350">
 
Рисунок 18 — Обработка запроса с четырьмя найденными остановками

По нажатию на конкретную так же выводится информация (рис. 19).

<img src="https://github.com/user-attachments/assets/1be2006e-f5fc-4a07-a029-686055220071" width="400">

Рисунок 19 — Вывод информации об одной из нескольких остановок

Если совпадений от пяти до девятнадцати, бот также формирует кнопки, но предварительная загрузка данных не производится. Это сделано с целью оптимизации работы с базой данных и экономии ресурсов. При нажатии на любую из кнопок бот динамически обращается к базе и возвращает подробную информацию только для выбранной остановки. Такая архитектура позволяет поддерживать стабильность системы при повышенной нагрузке.\
На рисунке 20 представлен пример обработки запроса //ботанический, где найдено восемь остановок.

<img src="https://github.com/user-attachments/assets/35a52674-0af5-462c-af0f-29722f269794" width="350">

Рисунок 20 — Обработка запроса с 16 найденными остановками

В случае, если по запросу найдено двадцать и более остановок, бот уведомляет пользователя о необходимости уточнения запроса, чтобы избежать перегрузки интерфейса и не выводить избыточную информацию. Примером служит запрос //ВДНХ, представленный на рисунке 21, по которому находится 35 остановочных пунктов, включая автобусные, трамвайные, троллейбусные платформы и остановки на смежных улицах. В таком случае пользователю выводится сообщение с просьбой конкретизировать свой запрос.

<img src="https://github.com/user-attachments/assets/6ddb91ee-23a6-4d5c-9f02-37558c7c41ea" width="350">

Рисунок 21 — Обработка запроса с более чем двадцатью остановками	

Если какая-то остановка вдруг не найдена в БД, пользователю выводится соответствующее сообщение (рис. 22).

<img src="https://github.com/user-attachments/assets/2e376349-1132-436d-8166-bbad855b8ff1" width="350">

Рисунок 22 — Обработка случая с отсутствующей в БД остановкой

Таким образом, реализованная логика обработки остановок позволяет гибко адаптироваться под разные сценарии пользовательских запросов от единичных совпадений до большого количества найденных результатов. Интеграция с геосервисом Яндекса обеспечивает точное определение адреса и визуализацию положения остановки на карте, что делает взаимодействие с ботом максимально информативным, интуитивно понятным и удобным для пользователя.

> [!NOTE]
> В результате выполненной работы продемонстрирована возможность построения эффективного, легкого в использовании, масштабируемого информационного сервиса, основанного на открытых данных и современных технологиях обработки информации.\
> Практическая значимость разработки заключается в создании доступного инструмента, обеспечивающего пользователей достоверной информацией о маршрутах общественного транспорта без необходимости установки дополнительных приложений.\
> Полученное решение может быть использовано в образовательных и демонстрационных целях, а также при дальнейшей разработке городских сервисов, опирающихся на открытые данные.\
> Система обладает потенциалом к дальнейшему развитию: может быть дополнена функциональностью отображения информации в виде карты, поддержки времени прибытия транспорта в реальном времени, многозадачной обработки и расширением перечня источников данных.\
> Это позволит повысить пользовательскую ценность решения и интегрировать его в более широкий контекст городских цифровых сервисов.
